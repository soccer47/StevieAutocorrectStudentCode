Name: Stevie K. Halprin

| Date    |      Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Update |
|:--------|:--------------:|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| March 5 |   7pm-7:40pm   |                                                                                                                                                                                                                               I thought for a while on how I would approach this problem set. As of right now I think I'll make 3 recursive methods, one for delete, one for swap, and one for add. I can then run them all on each other, with the base cases for all of them being hitting the threshold or finding a word in the dictionary. |
| March 6 |   7:45pm-8pm   |                         I spent a bit of time trying to implement my recursive approach above and realized that it would be pretty complicated to use the 3 recursive methods while also making my approach time and especially space efficient. I then thought about using a tree or TST instead (like for the problem set where we had to check if it existed in a dictionary or not). I think that I'll have to spend more time thinking about my approach, as this is starting to seem like a much more conceptually intricate problem set. |
| March 8 |  12pm-12:45pm  |                                                                          I spent some more time thinking about how I wanted to approach the problem set, and realized that I may as well start the quasi-recursive approach and see how it goes. I started implementing this approach and have almost finished my methods for delete, swap, and add, with each returning an ArrayList of letters that work with a threshold of 1. I will likely run them multiple times in the main method to get all possible variations of the original word. |
| March 8 | 12:45pm-1:30pm |                                                                                                                                                                                           I finished the methods for swap, delete, and add, and also have almost finished a first draft of my main method, where I run each method on all of the possible words found so far. I store all of these words as keys in a Hashmap, with the value being the number of edits it took to get to that word. I run [threshold] rounds of these checks.3 |
| March 8 |   3pm-3:40pm   |                  I finished my first draft and tried running my code using the tester files, however I quickly realized that the time complexity of my code was pretty bad. I tried running my code on the smallest test and it didn't finish, leading me to try to add in more break points to reduce unneeded operations, however I still haven't seen my code finish yet. I'll continue to try to make improvements to reduce time consumption, however I also might have to consider a different approach if the situation doesn't improve. |
| March 8 | 6:35pm-7:20pm  |                                                                                                                                                            I spent more time trying to make my code more time efficient, however I still take a very long time on even the small test case, and don't actually return the right top recommended word. I also thought about instead approaching the problem by potentially checking how many edits it would take to get to each word in the dictionary, however I don't know if that would work. |
| March 8 | 7:20pm-7:50pm  |                                                                                                                                                                                            I've started trying to implement a more mathematic approach by going through each word in the dictionary and seeing how many edits away each is from the typed word. I have a feeling that this will actually be a lot faster as it doesn't require me to go through a lot of unnecessary options. I've almost completed a first draft of this code. |
| March 8 | 7:50pm-8:15pm  |                                                                                  I feel like I'm so close to solving the first version of this problem. I realized that I could use longestSharedSubstring method that we just finished to find the difference between the typed word and the original word, and I've been trying to use this method to calculate the number of edits it takes to get from the typed word to the words in the dictionary. I'm still not returning an array of the right length but I feel like I'm super close. |
| March 9 |   2pm-2:30pm   |                                                                                                                                                                                                                                                            I've continued to try to get my code to work using the longest substring between typed and the dictionary words. At this point I think I'll have to change the longestSharedSubstring method to work with the code, as the ordering of the letters in the shared substrings matters. |
| March 9 |   2:30pm-3pm   | I realized that it would be easier to alter the longestSharedSubstring method to just return the minimum number of edits necessary to make one word match another. I'm now basically going at this problem with a tabulation approach, and I'm running the tabulation method on every word in the dictionary to find the ones with the lowest number of edits needed to match the typed word. I haven't figured out how to make the tabulation method return the right number of edits quite yet, but I think I'm getting closer to solving it. |


To add a new row to the table, click into a cell and then hit shift-enter.